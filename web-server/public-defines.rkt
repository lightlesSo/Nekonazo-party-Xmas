#lang racket
(require net/rfc6455)
(require json)
(require web-server/private/timer)
(define nazo-words-list (list->vector (string->jsexpr (file->string "asset/words-from-Nekonazo0.json"))))
(define nazo-words-list-length (vector-length  nazo-words-list))
(define ws-pool (make-immutable-hasheq))
(define name-status (make-immutable-hasheq)); (name #hasheq((dsf . df)(.))
(define room-status (make-immutable-hasheq)); (room #hasheq((drawsteps . df)(room . '(name name))(.))
(define root (make-hasheq (list (cons 'ws-pool ws-pool)( cons 'name-status name-status)(cons 'room-status room-status))))
;parameter是线程私有的
(define ws-pool 
	(case-lambda (() (hash-ref root 'ws-pool))
				((new-data) (hash-set! root 'ws-pool new-data)))
				#;((k v ) (ws-pool (hash-set (ws-pool) k v)))
				#;((k v fail) (ws-pool (hash-set (ws-pool) k v fail)));有用吗，对于更深层嵌套也没用 update也没有 就算有update 可以#: 深层也没法处理 还有remove 别了，反而会混乱，虽说能少些几个字
				)
(define room-status 
	(case-lambda (() (hash-ref root 'room-status ))
				((new-data) (hash-set! root 'room-status  new-data))))
(define name-status 
	(case-lambda (() (hash-ref root 'name-status))
				((new-data) (hash-set! root 'name-status new-data))))
(room-status (hash-set (room-status) "1" (make-hash '((names . ())(drawsteps . ())(gamestate . "ready"))))) ;;测试用
(room-status (hash-set (room-status) "2" (make-hash '((names . ())(drawsteps . ())(gamestate . "ready")))))
#;(define (name->client name (fail "meiyou"))
  (if (equal? fail "meiyou")
      (hash-ref ws-pool name)
      (hash-ref ws-pool name fail)))
(define name->client 
	(case-lambda ((name)(hash-ref (ws-pool) name))
		((name fail)(hash-ref (ws-pool) name fail))));这些都应该不要，但是这个可以作为一个例外 只是为了找到唯一对应关系
(define (room->namelist room (fail "meiyou"))
  (if (equal? fail "meiyou")
      (hash-ref (hash-ref room-status room ) 'names )
      (hash-ref (hash-ref room-status room (make-hash)) 'names fail)))
(define (name->status name (fail "meiyou"))
  (if (equal? fail "meiyou")
      (hash-ref name-status name)
      (hash-ref name-status name fail)))
(define (update-status! name key value (fail "meiyou"))
  (if (equal? fail "meiyou")
      ;(hash-update! name-status name (lambda (x)(hash-set x key value)))
      ;(hash-update! name-status name (lambda (x)(hash-set x key value)) fail)))
      (hash-set! (hash-ref name-status name) key value)
      (hash-set! (hash-ref name-status name fail) key value )));这行没用
(define (room->roomstatus room (fail "meiyou"))
  "似乎根本没用上"
  (if (equal? fail "meiyou")
      (hash-ref room-status room)
      (hash-ref room-status room fail)))
(define (send-json to-name type type2 whole-json)
  (ws-send! (name->client to-name)
            (jsexpr->string `#hasheq((type . ,type)
                                     (type2 . ,type2) 
                                     (content . ,whole-json)))))
(define (broadcast-json name-list type type2 whole-json)
  (map (lambda (name) (send-json name type type2 whole-json)) name-list))
(define (room-broadcast #:type (accord-type 'name) accord type type2 whole-json)  
  (cond ((equal? accord-type 'name) (broadcast-json (hash-ref (hash-ref room-status (hash-ref (hash-ref name-status accord) 'room)) 'names ) type type2 whole-json))
        ((equal? accord-type 'room) (broadcast-json (hash-ref (hash-ref room-status accord) 'names ) type type2 whole-json))
        (#t (displayln "room-broadcast UNKNOW param"))))
(define (init-room room)
  (define  this-room-status (hash-ref room-status room ))
  (begin (if (hash-has-key? this-room-status 'gametimer)
             (cancel-timer!  (hash-ref this-room-status 'gametimer))
             '())
         (hash-remove! this-room-status 'gametimer)
         (hash-remove! this-room-status 'nazo)
         (hash-remove! this-room-status 'drawname)
         (hash-set! this-room-status 'gamestate "ready")
         (hash-set! this-room-status 'drawsteps '())))
(define (send-current-rooms name)
  (define (oneroomstatus key value)
    (make-hash (list (cons 'room key) 
                     (cons 'peoplenum (length (hash-ref value 'names)))	  
                     (cons 'roomstatus (hash-ref value 'gamestate)))))
  (define roomsstatus (hash-map  room-status oneroomstatus))
  ;racket 在key为数字时 jsexpr->string会失效
  (send-json name "room" "currentrooms" `#hasheq((roomlist . ,roomsstatus))))
(define (obs-hash hashtable fun proc)
  "hashtable在fun执行后如果变化，就执行proc"
  (define old-hash-code (equal-hash-code hashtable))
  (begin0 (fun)
         ; (display old-hash-code)
          (if (equal? old-hash-code (equal-hash-code hashtable))
              (void)
              (proc))))
(provide (all-defined-out))