#lang racket
(require net/rfc6455)
(require json)
(require "public-defines.rkt")
(define (enter-room  name content)
  (define room-id (hash-ref content 'room ))
  (define in-room (room->namelist room-id '()))
  (define room-game-state (with-handlers ((exn:fail? (lambda(e) #f)))(hash-ref (hash-ref room-status room-id) 'gamestate)))  
  (if(not room-game-state)
    (begin (ws-send! (name->client name) (jsexpr->string
                                              `#hasheq((type . "account")
                                                       (type2 . "enterRoom")
                                                       (content . #hasheq((room . ,room-id)
                                                                          (status . "no-room"))))))
                )
    (if (> (length in-room) 5)
        (begin (ws-send! (name->client name) (jsexpr->string
                                              `#hasheq((type . "account")
                                                       (type2 . "enterRoom")
                                                       (content . #hasheq((room . ,room-id)
                                                                          (status . "full"))))))
                )
        (begin
          (hash-update! (hash-ref room-status room-id (make-hash )) 'names (lambda(x) (cons name x)) '())
          (update-status! name 'state "room")         
          (if (equal? room-game-state "game")
              (update-status! name 'gamestate "guess")
              (update-status! name 'gamestate "notready"))
          (update-status! name 'room room-id)         
          (ws-send! (name->client name) (jsexpr->string
                                         `#hasheq((type . "account")
                                                  (type2 . "enterRoom")
                                                  (content . #hasheq((room . ,room-id)
                                                                     (status . "ok")
                                                                     (roomgamestate . ,room-game-state)
                                                                     (characters . ,in-room))))))
          (one-in-out-room name in-room)))))
(define (one-in-out-room name others) 
  (define state (hash-ref (name->status name) 'state))
  (define gamestate (hash-ref (name->status name) 'gamestate "unknowgamestate-in-one-in-out-room-in-account-proc"))
  (define (send-message from to)
    (ws-send! (name->client to) (jsexpr->string
                                 `#hasheq((type . "account")
                                          (type2 . "inoutroom") 
                                          (content . #hasheq((name . ,from)
                                                             (gamestate . ,gamestate)
                                                             (state . ,state)))))))
  (map (lambda(x)(send-message name x)) others))
(define (exit-room name content)
  (define room (hash-ref (hash-ref name-status name) 'room))
  (begin (update-status! name 'state "rooms")
         (update-status! name 'gamestate "notgame")
         (update-status! name 'room "notroom")
         (one-in-out-room name (room->namelist room))
         (hash-update! (hash-ref room-status room) 'names (lambda (namelist) (remove name namelist)))
		 (if  (null? (hash-ref (hash-ref room-status room) 'names))    
         (hash-remove! room-status room)
           '())))
(define (account-proc name data) 
  "type2 return name +no now "

  (match data
    ((hash-table  ('type2 "enterRoom") ('content content)) #:when(equal? (hash-ref (hash-ref name-status name) 'state) "rooms")
     (enter-room  name  content))
    ((hash-table  ('type2 "exitRoom") ('content content)) #:when(equal? (hash-ref (hash-ref name-status name) 'state) "room")
     (exit-room  name  content))
    ))
(provide account-proc exit-room)